[{"content":"\u003ch2 id=\"my-experience-with-riot-games\"\u003eMy Experience with Riot Games\u003c/h2\u003e\n\u003cp\u003eFor the past 10 years, Riot Games has been the cornerstone of my gaming experience. I\u0026rsquo;ve always cherished those competitive moments, playing alongside friends to clutch those hard-earned victories in League of Legends and Valorant or watching last year DRX’s amazing world winning story. My enthusiasm was so contagious that I naturally wanted more friends to join the fray. Yet, the highly competitive nature of these games made it challenging for me as an advanced player to guide them. I often found it tough to step into their shoes, to see what they were seeing and understand what they didn\u0026rsquo;t yet know.\u003c/p\u003e\n\u003ch2 id=\"barrier-to-learn\"\u003eBarrier to learn\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/posts/League/barrier.png\" alt=\"me\"\u003e\u003c/p\u003e\n\u003cp\u003eFor those new to the realm of Riot game, stepping into a universe that has evolved over 13 years can be incredibly overwhelming. With League boasting over 200 items, 164 champions, and each champion possessing at least five distinct abilities, the volume of the raw information to grasp is staggering. Presenting a beginner with these numbers is a easy way to trigger a sense of awe, and perhaps, intimidation.\u003c/p\u003e\n\u003ch3 id=\"dont-want-to-make-it-easy\"\u003eDon’t want to make it easy\u003c/h3\u003e\n\u003cp\u003eOne of the intrinsic appeals of gaming is the sensation of overcoming the stress and challenges presented to the player. The greater the challege that players overcome is the more profound the sense of satisfaction. Both League of Legends and Valorant offer intense levels of competition, leading sometimes to conflicts between randomly matched teammates in their first normal queue against people. Many players feel overwhelmed during their very first match and choose to avoid playing League rest of their life after the horrible experience.\u003c/p\u003e\n\u003ch3 id=\"what-should-we-do-then\"\u003eWhat Should We Do Then?\u003c/h3\u003e\n\u003cp\u003eLast year, Mahjong, though considered unfamiliar board game in Korea, surged in popularity on Korean Twitch streams because of a mobile game. Around then, a small website began to gain traction in twitch chat with the tagline, \u0026ldquo;Watch this, and you\u0026rsquo;re set to play Mahjong with anyone!\u0026rdquo; Veteran players found it invaluable, frequently sharing it with newcomers before they start playing together. This sparked an idea in me: What if there existed a similar platform for games like League or Valorant? Such a tool could be the perfect way to convince my friends into my favorite games! Imagine the convenience for beginners, enabling the player group to quick intergration into matches alongside their more experienced friends.\u003c/p\u003e\n\u003cimg src=\"/posts/League/matchHistory.png\" style=\"display: block; margin-left: auto; margin-right: auto; width: 97%; height: 97%;\"/\u003e\n\u003cp\u003eBuilding on that thought, I’m developing a Valorant website as backend developer and product manager for my internship. Yes, there are numerous Valorant sites like tracker.gg that simply display past match histories and compute basic stats, such as headshot rates like the image above. But I wanted to show insights beyond that.\u003c/p\u003e\n\u003cp\u003eI want our website to be a starting point for beginners – a place where they can dive into curated content, gain the confidence to play alongside their friends, and understand their baisc in-game roles. Furthermore, I want to offer more than just the basics; I aim to provide insights into the game\u0026rsquo;s environment and share intriguing facts. I\u0026rsquo;ll be sharing into some of these captivating stats in this post.\u003c/p\u003e\n\u003ch2 id=\"beyond-a-basic-tutorial\"\u003eBeyond a Basic Tutorial\u003c/h2\u003e\n\u003cp\u003eWhile tutorials offer a grasp on the very foundational controls, mastery over intricate strategies and positional understanding is vital for actual gameplay. Delving into specific insights can significantly enhance a beginner\u0026rsquo;s experience when queued with veteran players. Furthermore, some information may help the veteran players to play with newbies in their games too.\u003c/p\u003e\n\u003cp\u003eTaking Valorant as an example, beginners often find themselves grappling with unfamiliar elements in games. The agent unfamiliarity tends to push them towards champions that appear more appealing and easy. A case in point is Sage. She heals and revives an ally with a point click, which seems very easy like Mercy in Overwatch. However, ironically, Sage is hard because of her strong supporting ability because it requires her to stay alive and farm ult points. I confirmed my thoughts when I analyzed the data from Valorant API with Python and MongoDB.\u003c/p\u003e\n\u003cimg src=\"/posts/League/sage.png\" style=\"display: block; margin-left: auto; margin-right: auto; width: 97%; height: 97%;\"/\u003e\n\u003cp\u003eThis chart is represents the agents’ win rate difference between high and low tier. Higher the bar means the agent performs better at high tier than low tier. The stark performance gap from Sage suggests that her perceived simplicity entices many newcomers, but it may not be the best agent for beginners.\u003c/p\u003e\n\u003ch3 id=\"is-presence-of-smoke-crucial\"\u003eIs Presence of Smoke Crucial?\u003c/h3\u003e\n\u003cp\u003eMeanwhile, veteran players, understanding the nuances and the importance of smokes, often prioritize incorporating it into their team strategies. On the other hand, newcomers, not entirely grasping this concept, tend to opt for more straightforward agents. These veteran players, aware of the challenges of attacking or defending without the right smoke placement, can sometimes express their frustration towards the newer players\u0026rsquo; agent selection or lack of understanding how to smoke.\u003c/p\u003e\n\u003cp\u003eI want to emphasize my significant observation to the veteran players: the presence or absence of smoke doesn’t always correlate with win rates! So, there\u0026rsquo;s no need to agonize over crafting the \u0026lsquo;perfect\u0026rsquo; team composition for your ranked games with random teammates.\u003c/p\u003e\n\u003cimg src=\"/posts/League/smoke.png\" style=\"display: block; margin-left: auto; margin-right: auto; width: 97%; height: 97%;\"/\u003e\n\u003cp\u003eThis chart reveals that around 8% of rounds lacked a smoke agent (Controller) within a team composition. However, for games played at the platinum tier or above, this number shrunk to 3.24%. This suggests that higher-tier players prioritize having at least one controller in their lineup. If we could widely share these insights, it might alleviate the undue pressure players feel about team compositions. In turn, this could greatly enhance the gaming experience, especially when paired with random teammates.\u003c/p\u003e\n\u003ch3 id=\"wrapping-up-the-insights\"\u003eWrapping Up the Insights\u003c/h3\u003e\n\u003cp\u003eThroughout my journey from a beginner Sage player to an intermediate at the Platinum rank in Valorant, many insights gradually formed in my mind. While I\u0026rsquo;ve shared a few of these findings here, trust me, the rabbit hole goes much deeper. I\u0026rsquo;ve rigorously investigated almost every piece of data output from Valorant\u0026rsquo;s match API to answer my curiosity about the Valorant statistics.\u003c/p\u003e\n\u003cp\u003eHowever, due to my contractual obligations with the company, there\u0026rsquo;s a plethora of information I need to withhold – at least for now. That said, these insights will be instrumental in shaping the website we\u0026rsquo;re currently developing, ensuring it becomes a rich resource for both newbies and veterans. I am very excited to bring these insights into the website!\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/posts/League/meAtT1.png\" alt=\"me\"\u003e\u003c/p\u003e\n\u003cp\u003eAs a gamer and e-sports fan, I\u0026rsquo;ve experienced firsthand the thrill, strategy, and camaraderie games can bring. I genuinely hope more people come to appreciate and enjoy what games can offer.\u003c/p\u003e\n\u003cp\u003eIn line with this passion, I have been harnessing my backend development skills to support the website development of my current internship and create a platform to bridge the huge gap between newbies and seasoned players. As next step, I will apply for a Riot 2024 summer internship to immerse myself further into a community and company I want to join to learn! But regardless of the outcome, my commitment will remain unchanged. Even if I don\u0026rsquo;t secure a spot at Riot, my ambition is to persist in the gaming industry, especially in backend development roles, drawing from the experiences of my current internship.\u003c/p\u003e\n","description":"From Valorant insights to my Riot internship aspirations: A data-driven journey","image":"/posts/League/meAtRiot.png","permalink":"https://jooncode.com/blogs/game/valorantinsights/","title":"From Gamer to Dev: Bridging the Gap for Valorant Newbies"},{"content":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eDesign patterns are essential in development as they provide a structured approach to solve common problems. Object-oriented design patterns are the most widely used patterns, and they form the backbone of most software applications.\n\u003cimg src=\"/posts/OOD/mypic.PNG\" style=\"display: block; margin-left: auto; margin-right: auto; width: 80%; height: 80%;\"/\u003e\nIn this post, I\u0026rsquo;ll share my experience as a OOD TA and insights on how these patterns work and provide you with some sample code to help you understand them better. We will explore Singleton, Factory, Strategy, and Observer patterns, and how these patterns can be used to improve the quality of your designs and provide you with code samples to illustrate their implementation.\u003c/p\u003e\n\u003ch2 id=\"singleton-pattern\"\u003eSingleton Pattern\u003c/h2\u003e\n\u003cp\u003eSingleton pattern helps in creating only one instance of a class and ensures that this instance is globally accessible throughout the program. The pattern works by defining a class that has only one instance and provide global point of access to that instance.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-class\" data-lang=\"class\"\u003e    private static class singleInstanceHolder{\r\n        private static final Singleton INSTANCE = new Singleton();\r\n    }\r\n\r\n    public static Singleton getInstance() {\r\n        return singleInstanceHolder.INSTANCE;\r\n    }\r\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe \u0026lsquo;INSTANCE\u0026rsquo; variable is the only instance of Singleton class. By declaring \u0026lsquo;INSTANCE\u0026rsquo; as \u0026lsquo;final\u0026rsquo;, it ensures that there is only one instance of the \u0026lsquo;Singleton\u0026rsquo; class created becuase final keyword prevents the \u0026lsquo;INSTANCE\u0026rsquo; variable from being reassigned after it is initialized.\u003c/p\u003e\n\u003cp\u003eThe \u0026lsquo;getInstance()\u0026rsquo; method returns the single instance of the class as a getter. \u0026lsquo;public\u0026rsquo; keywords allow the method to be accessed from outside the Singleton class. It provides the global access point to our instance throught the program.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-public\" data-lang=\"public\"\u003e    public static void main(String[] args) {\r\n        \r\n        Singleton a = Singleton.getInstance();\r\n        Singleton b = Singleton.getInstance();\r\n        System.out.println(a.hashCode());\r\n        System.out.println(b.hashCode());\r\n        if (a==b) {\r\n            System.out.print(\u0026#34;output: true\u0026#34;);\r\n        }\r\n    }\r\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eoutput: true\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBoth \u0026lsquo;a\u0026rsquo; and \u0026lsquo;b\u0026rsquo; refers to the same instance of the Singleton class. Therefore, \u0026lsquo;a.hashCode()\u0026rsquo;  and \u0026lsquo;b.hashCode()\u0026rsquo; will always be equal. If you understand the concept of singleton pattern, you will be able to use it to create a database connection, a thread pool, or a cache.\u003c/p\u003e\n\u003ch2 id=\"factory-pattern\"\u003eFactory Pattern\u003c/h2\u003e\n\u003cp\u003eThe factory pattern is a creational pattern that allows you to create objects without specifying the exact class of object that will be created. Instead you delegate the creation of smaller objects to a separate class called a factory. This pattern is useful when you need to create many objects of the same type, but with different values or properties.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-public\" data-lang=\"public\"\u003e    //abstract method, so subclass must implement this method \r\n    public abstract int getPrice(); \r\n    \r\n    @Override\r\n    public String toString(){\r\n        return \u0026#34;Price: \u0026#34;+ this.getPrice();\r\n    }\r\n}\r\npublic class Latte extends Coffee { \r\n    private int price; \r\n    \r\n    public Latte(int price){\r\n        this.price=price; \r\n    }\r\n    @Override\r\n    public int getPrice() {\r\n        return this.price;\r\n    } \r\n}\r\npublic class Americano extends Coffee { \r\n    private int price; \r\n    \r\n    public Americano(int price){\r\n        this.price=price; \r\n    }\r\n    @Override\r\n    public int getPrice() {\r\n        return this.price;\r\n    } \r\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-public\" data-lang=\"public\"\u003e    //factory method to create object of type Coffee\r\n    public static Coffee getCoffee(String type, int price){\r\n        if(\u0026#34;Latte\u0026#34;.equalsIgnoreCase(type)) {\r\n            return new Latte(price)\r\n        };\r\n        else if(\u0026#34;Americano\u0026#34;.equalsIgnoreCase(type)) {\r\n            return new Americano(price)\r\n        };\r\n        else {\r\n            System.out.println(\u0026#34;Invalid Coffee Type\u0026#34;);\r\n        } \r\n    }\r\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe have an abstract class Coffee with an abstract method getPrice(). We then have two concrete classes that extend Coffee: Latte and Americano. Latte and Americano have a constructor that takes in a price and initialize the private field.\u003c/p\u003e\n\u003cp\u003eThere could be more concrete classes that extend Coffee, such as Espresso, Mocha, etc. If we create a new coffee object, we would have to write many lines of code to create the object with field initialization. This is where the factory pattern comes in!\u003c/p\u003e\n\u003cp\u003eWe have a CoffeeFactory class that has a static method getCoffee(). This method takes in a type and a price and returns a Coffee object. The getCoffee() method uses the type parameter to determine which concrete class to instantiate. The price parameter is passed to the constructor of the concrete class. This way, we can create a coffee object without having to write a lot of code. We can create new coffee obejcts just by calling the getCoffee(type, price) method. The output of the code below is as follows:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-public\" data-lang=\"public\"\u003e     public static void main(String []args){ \r\n        Coffee latte = CoffeeFactory.getCoffee(\u0026#34;Latte\u0026#34;, 5);\r\n        Coffee ame = CoffeeFactory.getCoffee(\u0026#34;Americano\u0026#34;, 4); \r\n        System.out.println(\u0026#34;Factory latte: \u0026#34;+ latte);\r\n        System.out.println(\u0026#34;Factory ame: \u0026#34;+ ame); \r\n     }\r\n} \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eoutput:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eFactory latte: Price: 4000\r\nFactory ame: Price: 3000\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFactory pattern is a powerful design pattern that allows you to create objects without specifying the exact class of object that will be created. If you are writing a program that needs to create many objects of the same type, you should consider using the factory pattern.\u003c/p\u003e\n\u003ch2 id=\"strategy-pattern\"\u003eStrategy Pattern\u003c/h2\u003e\n\u003cp\u003eStrategy pattern is a behavioral design pattern that allows you to define a family of algorithms, put each of them into a separate class, and make their objects interchangeable. The pattern allows you to change the behavior of an object by changing the object\u0026rsquo;s strategy.\u003c/p\u003e\n\u003cp\u003eHere\u0026rsquo;s a simple example of the strategy pattern in Java: Suppose you are writing a program that performs some operation on two integers. You would first define an interface that defines the operation:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003epublic interface Operation {\r\n    public int performOperation(int a, int b);\r\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis interface is simply defining a method that takes two integers and returns an integer. You would then create two classes that implement this interface for each type of operation you need to perform. For example:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-public\" data-lang=\"public\"\u003e    public int performOperation(int a, int b) {\r\n        //1+1 = 2\r\n        return a + b;\r\n    }\r\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-public\" data-lang=\"public\"\u003e    public int performOperation(int a, int b) {\r\n        //1 cat 1 = 11\r\n        return Integer.parseInt(Integer.toString(a) + Integer.toString(b));\r\n    }\r\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn these examples, Addition performs addition on two integers, while Concatenation concatenates them as strings and then parses the result back to an integer.\u003c/p\u003e\n\u003cp\u003eFinally, you would create a class that uses these operations.\nFor example:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-public\" data-lang=\"public\"\u003e    private Operation operation;\r\n    \r\n    public void setOperation(Operation operation) {\r\n        this.operation = operation;\r\n    }\r\n    \r\n    public int performOperation(int a, int b) {\r\n        return operation.performOperation(a, b);\r\n    }\r\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis calculator class has a field called operation that is of type Operation. This field is set to an instance of Addition or Concatenation. The performOperation() method calls the performOperation() method on the operation field. This allows you to change the behavior of the calculator by just changing the operation field.\u003c/p\u003e\n\u003cp\u003eOverall, Strategy pattern allows you to change the behavior of an object by changing the object\u0026rsquo;s strategy. This is useful when you have multiple algorithms that perform the same task and you want to be able to switch between them at runtime.\u003c/p\u003e\n\u003ch2 id=\"observer-pattern\"\u003eObserver Pattern\u003c/h2\u003e\n\u003cp\u003eObserver Pattern is a behavioral design pattern that allows one or more objects to watch an object and be notified when the object state updates. The observer pattern is also known as the publish/subscribe pattern. This pattern is useful when you have a 1-to-many relationship in objects. For example, if you have a relationship between employees and managers, then you can use the observer pattern to notify managers whenever an employee updates their status.\u003c/p\u003e\n\u003cp\u003eThis is example code of the observer pattern:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-import\" data-lang=\"import\"\u003eimport java.util.List;\r\n\r\ninterface Subject {\r\n    public void register(Observer obj);\r\n    public void notifyObservers();\r\n    public Object getUpdate(Observer obj);\r\n}\r\n\r\ninterface Observer {\r\n    public void update(); \r\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn this example, we have a Subject interface that defines the methods that must be implemented as a subject. The register() method is used to register an observer object. The notifyObservers() method is used to notify all registered observers. The getUpdate() method is a getter method to obtain the most recent message from a observer.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-class\" data-lang=\"class\"\u003e    //list of observers\r\n    private List\u0026lt;Observer\u0026gt; observers;\r\n    //message sent to the topic\r\n    private String message; \r\n\r\n    //constructor\r\n    public Topic() {\r\n        this.observers = new ArrayList\u0026lt;\u0026gt;();\r\n        this.message = \u0026#34;\u0026#34;;\r\n    }\r\n\r\n    //method to attach an observer to the subject\r\n    @Override\r\n    public void register(Observer obj) {\r\n        //check if observer is already registered\r\n        if (!observers.contains(obj)) {\r\n            observers.add(obj);\r\n        }\r\n        //else do nothing\r\n    }\r\n\r\n    @Override\r\n    public void notifyObservers() {\r\n        //for each loop through all observers and notify them \r\n        this.observers.forEach(Observer::update); \r\n    }\r\n\r\n    //method to get updates from subject\r\n    @Override\r\n    public String getUpdate(Observer obj) {\r\n        //get the message from the observer\r\n        return this.message;\r\n    } \r\n    \r\n    //method to post message to the topic\r\n    public void postMessage(String msg) {\r\n        //set the message\r\n        this.message = msg;\r\n\r\n        //notify all observers to post message\r\n        notifyObservers();\r\n    }\r\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-class\" data-lang=\"class\"\u003e    //name of the observer\r\n    private String name;\r\n    private Subject topic;\r\n\r\n    //constructor\r\n    public TopicSubscriber(String name, Subject topic) {\r\n        this.name = name;\r\n        this.topic = topic;\r\n    }\r\n\r\n    //method to print out the update. used by Subject class.\r\n    @Override\r\n    public void update() {\r\n        String msg = topic.getUpdate(this); \r\n        System.out.println(name + \u0026#34; \u0026gt;\u0026gt; \u0026#34; + msg); \r\n    } \r\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn the example, we have a Topic class that creates a topic that observers can subscribe to. The TopicSubscriber class creates an observer that can subscribe to a topic.\u003c/p\u003e\n\u003cp\u003eFinally, we have a main class that creates a topic and two observers: a and b. The observers are then registered to the topic. The topic then posts a message, which notifies all observers to print out the message.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-public\" data-lang=\"public\"\u003e    public static void main(String[] args) {\r\n        Topic topic = new Topic(); \r\n        Observer a = new TopicSubscriber(\u0026#34;a\u0026#34;, topic);\r\n        Observer b = new TopicSubscriber(\u0026#34;b\u0026#34;, topic);\r\n        topic.register(a);\r\n        topic.register(b);\r\n   \r\n        topic.postMessage(\u0026#34;Hello World\u0026#34;); \r\n    }\r\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eoutput:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ea \u0026gt;\u0026gt; Hello World\r\nb \u0026gt;\u0026gt; Hello World\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn this example, the topic is the subject and the observers are the objects that are watching the subject. The observers are notified whenever the subject updates its state. It demonstarted how the observer pattern can create a 1-to-many relationship between objects. Object pattern is used in many applications, such as in the Java Swing library to build Graphic User Interface.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eIn this post, we learned about the 4 common design patterns: Singleton pattern, the Factory pattern, the Strategy pattern, and the Observer pattern. A wise use of these patterns will create more flexible and reusable code for your program (they are very useful for OOD class as well). I will be writing more posts about design patterns such as Adaptor and MCV in the future, so stay tuned!\u003c/p\u003e\n","description":"Explanation of Design Patterns for beginners","image":"/posts/OOD/java.png","permalink":"https://jooncode.com/study/ood/","title":"Design Patterns"},{"content":"\u003cp\u003eNothing crazy. Just some typing video with my first custom keyboard.\n\n\u003cdiv style=\"position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;\"\u003e\n  \u003ciframe src=\"https://www.youtube.com/embed/wZf8Oi4YeHw\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\" allowfullscreen title=\"YouTube Video\"\u003e\u003c/iframe\u003e\n\u003c/div\u003e\n\u003c/p\u003e\n","description":"FrogTKL typing video","image":"/posts/keyboard/frogtkl.jpg","permalink":"https://jooncode.com/blogs/keyboard/frogtkl/","title":"My first custom keyboard"},{"content":"\u003cimg src=\"/me/military.jpg\" style=\"display: block; margin-left: auto; margin-right: auto; width: 50%; height: 50%;\"/\u003e\n\u003cimg src=\"/me/northeastern.jpg\" style=\"display: block; margin-left: auto; margin-right: auto; width: 50%; height: 50%;\"/\u003e\n\u003cimg src=\"/me/Dinner.jpg\" style=\"display: block; margin-left: auto; margin-right: auto; width: 50%; height: 50%;\"/\u003e\n\u003cimg src=\"/me/newyork.jpg\" style=\"display: block; margin-left: auto; margin-right: auto; width: 50%; height: 50%;\"/\u003e\n\u003cimg src=\"/me/pack.jpg\" style=\"display: block; margin-left: auto; margin-right: auto;width: 50%; height: 50%;\"/\u003e\n\u003cimg src=\"/me/pho.jpg\" style=\"display: block; margin-left: auto; margin-right: auto;width: 50%; height: 50%;\"/\u003e\n","description":"Great to be back to School","image":"/me/northeastern.jpg","permalink":"https://jooncode.com/blogs/gallery/2022/","title":"My 2022: Coming back from military!"},{"content":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eSoftware engineering is a rapidly changing field. Every day, new tools and technologies are being released that can help developers more efficiently create and manage applications. As a software engineer, it can be difficult to keep up with all the changes and ensure that you are staying up to date with the latest best practices. In this blog post, I will share my experience reaching out to my \u003ca href=\"https://www.youtube.com/channel/UCqI5lyTpC79pOy2D-VXAMdA\"\u003efavorite league data analysis youtuber\u003c/a\u003e\u0026rsquo;s company and apply my knowlege and skill out side of class.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/projects/ps.png\" alt=\"ps spectator\"\u003e\u003c/p\u003e\n\u003ch2 id=\"how-i-reached-out-to-them\"\u003eHow I reached out to them\u003c/h2\u003e\n\u003cp\u003eAfter completing the basic Computer Science classes, I looked for interesting side projects to join. I sent an e-mail to one of my favorite League YouTuber expressing my interest to join any proejcts and my desire to collaborate. To my surprise, the CEO responded and suggested that I start by helping with management of Discord community called NoTrollz for league of legend friendly matchs between clubs first. Then see if we could further develop something once we got to know each other better. I was thrilled to have the opportunity to work with a real-world company and acquire some valuable experience.\u003c/p\u003e\n\u003ch2 id=\"working-on-the-project\"\u003eWorking on the Project\u003c/h2\u003e\n\u003cp\u003eMy recent project was to create a discord bot that manages user\u0026rsquo;s roles and teams. The goal of the project was to learn Typescript and NestJs that would make the bot to be accessible to company\u0026rsquo;s current work environment. One of the biggest challenges I faced was learning how to learning new language and framework with limited amount of documents. These tools are relatively new and I had no prior experience working with them. Despite the challenges, I was ultimately able to create a simple bot that automated the chore for the server manager.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/projects/docker+postgresql.jpeg\" alt=\"docker+postgresql\"\u003e\u003c/p\u003e\n\u003ch2 id=\"continuing-education\"\u003eContinuing Education\u003c/h2\u003e\n\u003cp\u003eAfter the first part, I had a meeting with a senior developer from the company I\u0026rsquo;m working with. During the meeting, we discussed the current feature and the senior developer suggested to create a user data base and develop a more advanced automation bot.\u003c/p\u003e\n\u003cp\u003eThe automation of the feature could not be done solely with Discord\u0026rsquo;s features and a database was necessary to handle user\u0026rsquo;s roles and teams for extendability and sustainability. To match the company\u0026rsquo;s existing system, I learned and implemented Docker Compose and PostgreSQL. To ensure my plan of action would work, I conducted research and experimented with the new technologies before implementing them into the project.\u003c/p\u003e\n\u003ch2 id=\"dockerizing-the-bot\"\u003eDockerizing the bot\u003c/h2\u003e\n\u003cp\u003eTo begin with, I created a devcontainer with psql database in VS code, which allowed me to develop and test my bot in a containerized environment. Since this bot will run under AWS in future, I had to create the containerized environment to minimize unexpected bug. This was a crucial step in ensuring that my development environment was consistent across different machines.\u003c/p\u003e\n\u003cp\u003eNext, I built a data table using TypeORM Entity. When building the data table for my Discord bot, I took into consideration the potential future development plans and added data types that I would need from users.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e@Entity()\nexport class notrollz_entity extends BaseEntity {\n    @PrimaryGeneratedColumn(\u0026#34;uuid\u0026#34;)\n    uuid: string\n\n    @Index(\u0026#34;discord_id\u0026#34;, { unique: true })\n    @Column({ type: \u0026#34;varchar\u0026#34; })\n    discord_id: string\n\n    @Column({ type: \u0026#34;varchar\u0026#34; })\n    discord_tag: string\n\n    @Column({ type: \u0026#34;varchar\u0026#34; })\n    summoner_name: string\n\n    @Column({\n        type: \u0026#34;varchar\u0026#34;,\n        default: \u0026#34;\u0026#34;\n    })\n    team_name: string\n\n    @Column({\n        type: \u0026#34;boolean\u0026#34;,\n        default: false\n    })\n    team_catain?: boolean\n\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOne issue I encountered while building the data table was with the formatting of the Discord IDs. To resolve this, I used the uuid generator from Node.js to generate unique IDs for each user and gave the unique property to discord_id to prevent duplicate user registration on the database. By creating a well-structured data table with appropriate data types and using a unique ID generator, I was able to ensure that my Discord bot could accurately and efficiently store and retrieve user data. I then sent a query from my nestjs app with typeorm to qsql in the devcontainer to test the functionality of data table.\u003c/p\u003e\n\u003cimg src=\"/projects/psql_command.PNG\" style=\"display: block; margin-left: auto; margin-right: auto; width: 97%; height: 97%;\"/\u003e\n\u003cp\u003eAfter completing the initial development of the bot, I made the nestjs app into a Docker image and included it in a docker-compose file. This allowed me to easily deploy the bot to different environments and delegate the bot service to AWS instead of local computer. I also built a connection to psql in the new image with conscious volume mount, which was necessary for persisting data. When the connection was successful, I was very happy with my progress.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/projects/discord_usage.PNG\" alt=\"discord_usage\"\u003e\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eOverall, my experience working on this project was very rewarding. In a short amount of time, I was able to apply my knowledge of Object Oriented Design and acquire new experiences with docker containers, postgres, and javascript. Continuous education is an important part of staying up to date in the ever-changing world of software engineering and this project gave me the great lesson. By researching and experimenting with the latest tools and technologies, I am looking forward to create an advanced bot that improved the workflow of the community management of the company.\u003c/p\u003e\n","description":"Elaboration of my side project","image":"/projects/Bot_github.png","permalink":"https://jooncode.com/study/nestdiscordbot/","title":"Discord Bot Development story"},{"content":"\u003ch2 id=\"what-if-there-is-faker-bot-in-league\"\u003eWhat if there is Faker Bot in League?\u003c/h2\u003e\n\u003cp\u003eAs a computer science student, I find artificial intelligence (AI) bots fascinating. I want to extend the AI idea within the context of popular video games. With the development of AI technology, the way we play video games has drastically changed. AI-powered video games are now more interactive and immersive than ever before and have opened up a world of possibilities for gamers.\u003c/p\u003e\n\u003cp\u003eAI technology is also being used to create computer-controlled opponents that are smarter and learn from their mistakes, making the game much more challenging and fun. Moreover, AI-driven games can generate unique and customizable environments for players to explore and enjoy. These AI-driven environments can give rise to the development of new meta, creating new and exciting ways to play these games.\u003c/p\u003e\n\u003cp\u003eThe thought of an AI playing League of Legends at the highest level is an inspiring one. In order for it to play at a top level, it would need a massive amount of data from pro games and solo ranks with knowledge to be able to accurately react to in-game events in real-time. This would include its ability to understand every lane, item and champion interaction, as well as understanding the meta at a certain point in time.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/posts/League/humanVSai.jpg\" alt=\"Image from Sejong University\"\u003e\u003c/p\u003e\n\u003cp\u003eThere was an simlar attempt to create a \u0026ldquo;Pro Gamer AI\u0026rdquo; in Starcraft in 2017 at Sejong University, but it was not successful at the time because they were not able to build machine learning structure for the real time simulation games. For an AI to play at a top level, it would need to understand a massive amount of data from pro games and solo ranks, as well as knowledge to be able to accurately react to in-game events in real-time. This would include its ability to understand every lane, item and champion interaction, as well as understanding the meta at a certain point in time.\u003c/p\u003e\n\u003cp\u003eIt is fascinating to think about how this AI would be played. Would it still be EU meta, or would there be outstanding champions according to AI? Its ability to react to in-game events could make it an even more exciting player to watch. Additionally, an AI playing LOL at an AlphaGo level could potentially revolutionize the game with new meta led by AI and provide new insights for pro league games win percentage according to current situation.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/posts/League/LOL_Crowd.jpg\" alt=\"League Crowd\"\u003e\u003c/p\u003e\n\u003cp\u003eThe potential for AI technology in League of Legends is truly remarkable. As we imagine the possibilities, it\u0026rsquo;s clear that this technology has the power to transform the game in exciting new ways. The AI-led meta could open up entirely new strategies and tactics, and provide deep insights into the performance of professional teams and their win percentages in real-time. Furthermore, it has the potential to revolutionize the way intermediate-level players practice and improve their skills. By offering a challenging, dynamic and ever-changing AI opponent, players will no longer have to rely on boring or repetitive normal AI matches to sharpen their abilities. The future of League of Legends and AI technology is truly exciting. As I learn more about league API data and AI, I want to develop AI model for the pro league strategies!\u003c/p\u003e\n","description":"Thoughts about AI as a player in League of Legend","image":"/posts/League/faker.jpeg","permalink":"https://jooncode.com/blogs/game/leagueaibot/","title":"AI League of Legend"}]